# Integration Strategy: Unified Backend Approach

**My Recommendation: Option B - Merge into Single Express Backend**

Here's why this is the best path forward:

## Why Single Backend Wins

1. **Simpler Deployment**: One service to deploy, one URL to configure
2. **Easier Development**: One `npm start`, everything works
3. **Better for Users**: No confusion about which backend does what
4. **Cost Effective**: One server instance instead of two
5. **Unified API**: All camera operations under one roof

---

## Implementation: Express Backend with Python Subprocess

Since you already have Express running on port 5000, let's add RTSP functionality to it by spawning Python as a subprocess.

### **Updated Backend Structure**

```
/backend
  ├── package.json
  ├── server.js (existing Express server)
  ├── routes/
  │   ├── moondream.js (existing)
  │   └── rtsp.js (NEW - RTSP proxy routes)
  ├── services/
  │   └── rtspManager.js (NEW - manages Python subprocess)
  ├── python/
  │   ├── requirements.txt
  │   ├── rtsp_server.py (standalone RTSP service)
  │   ├── services/
  │   │   ├── __init__.py
  │   │   ├── rtsp_service.py
  │   │   └── camera_manager.py
  │   └── .env
  └── .env
```

---

## Complete Implementation

### **1. Update backend/package.json**

Add Python subprocess management:

```json
{
  "name": "visual-reasoning-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "setup-python": "cd python && pip install -r requirements.txt",
    "test-rtsp": "cd python && python rtsp_server.py"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "axios": "^1.6.0",
    "ws": "^8.14.2",
    "child_process": "^1.0.2"
  }
}
```

### **2. Create backend/services/rtspManager.js**

```javascript
const { spawn } = require('child_process');
const axios = require('axios');
const path = require('path');

class RTSPManager {
  constructor() {
    this.pythonProcess = null;
    this.isRunning = false;
    this.pythonPort = 8082;
    this.baseUrl = `http://localhost:${this.pythonPort}`;
  }

  async start() {
    if (this.isRunning) {
      console.log('RTSP service already running');
      return;
    }

    console.log('Starting Python RTSP service...');

    const pythonPath = path.join(__dirname, '../python');
    
    // Spawn Python subprocess
    this.pythonProcess = spawn('python', ['rtsp_server.py'], {
      cwd: pythonPath,
      env: { ...process.env, PORT: this.pythonPort.toString() }
    });

    // Handle stdout
    this.pythonProcess.stdout.on('data', (data) => {
      console.log(`[RTSP] ${data.toString().trim()}`);
    });

    // Handle stderr
    this.pythonProcess.stderr.on('data', (data) => {
      console.error(`[RTSP ERROR] ${data.toString().trim()}`);
    });

    // Handle process exit
    this.pythonProcess.on('close', (code) => {
      console.log(`RTSP service exited with code ${code}`);
      this.isRunning = false;
      this.pythonProcess = null;
    });

    // Wait for service to be ready
    await this.waitForReady(30000); // 30 second timeout
    
    this.isRunning = true;
    console.log(`RTSP service ready on port ${this.pythonPort}`);
  }

  async waitForReady(timeout = 30000) {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      try {
        const response = await axios.get(`${this.baseUrl}/health`, { timeout: 1000 });
        if (response.data.status === 'ok') {
          return true;
        }
      } catch (error) {
        // Service not ready yet, wait and retry
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    throw new Error('RTSP service failed to start within timeout');
  }

  async stop() {
    if (!this.pythonProcess) {
      return;
    }

    console.log('Stopping RTSP service...');
    
    this.pythonProcess.kill('SIGTERM');
    
    // Force kill after 5 seconds if still running
    setTimeout(() => {
      if (this.pythonProcess) {
        this.pythonProcess.kill('SIGKILL');
      }
    }, 5000);

    this.isRunning = false;
    this.pythonProcess = null;
  }

  // Proxy methods to Python backend
  async connectCamera(cameraId, ip, username, password, streamPath = '/1') {
    const response = await axios.post(`${this.baseUrl}/api/cameras/connect`, {
      cameraId,
      ip,
      username,
      password,
      streamPath
    });
    return response.data;
  }

  async disconnectCamera(cameraId) {
    const response = await axios.post(`${this.baseUrl}/api/cameras/disconnect`, {
      cameraId
    });
    return response.data;
  }

  async getCameraStatus(cameraId) {
    const response = await axios.get(`${this.baseUrl}/api/cameras/${cameraId}/status`);
    return response.data;
  }

  async getFrame(cameraId) {
    const response = await axios.get(`${this.baseUrl}/api/cameras/${cameraId}/frame`, {
      responseType: 'arraybuffer'
    });
    return response.data;
  }

  getWebSocketUrl() {
    return `ws://localhost:${this.pythonPort}/ws`;
  }

  getStatus() {
    return {
      running: this.isRunning,
      port: this.pythonPort,
      baseUrl: this.baseUrl
    };
  }
}

module.exports = new RTSPManager();
```

### **3. Create backend/routes/rtsp.js**

```javascript
const express = require('express');
const router = express.Router();
const rtspManager = require('../services/rtspManager');

// Connect to camera
router.post('/connect', async (req, res) => {
  try {
    const { cameraId, ip, username, password, streamPath } = req.body;
    
    if (!cameraId || !ip) {
      return res.status(400).json({ error: 'Missing required fields: cameraId, ip' });
    }

    const result = await rtspManager.connectCamera(
      cameraId,
      ip,
      username || 'admin',
      password || 'admin',
      streamPath || '/1'
    );

    res.json(result);
  } catch (error) {
    console.error('Camera connection error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Disconnect camera
router.post('/disconnect', async (req, res) => {
  try {
    const { cameraId } = req.body;
    
    if (!cameraId) {
      return res.status(400).json({ error: 'Missing cameraId' });
    }

    const result = await rtspManager.disconnectCamera(cameraId);
    res.json(result);
  } catch (error) {
    console.error('Camera disconnection error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get camera status
router.get('/:cameraId/status', async (req, res) => {
  try {
    const { cameraId } = req.params;
    const status = await rtspManager.getCameraStatus(cameraId);
    res.json(status);
  } catch (error) {
    console.error('Status error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get single frame
router.get('/:cameraId/frame', async (req, res) => {
  try {
    const { cameraId } = req.params;
    const frame = await rtspManager.getFrame(cameraId);
    
    res.set('Content-Type', 'image/jpeg');
    res.send(Buffer.from(frame));
  } catch (error) {
    console.error('Frame error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get WebSocket URL for streaming
router.get('/websocket-url', (req, res) => {
  res.json({
    url: rtspManager.getWebSocketUrl()
  });
});

// Get RTSP service status
router.get('/status', (req, res) => {
  res.json(rtspManager.getStatus());
});

module.exports = router;
```

### **4. Update backend/server.js**

```javascript
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const rtspManager = require('./services/rtspManager');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// Import routes
const moondreamRoutes = require('./routes/moondream'); // Your existing routes
const rtspRoutes = require('./routes/rtsp');

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    services: {
      express: 'running',
      rtsp: rtspManager.getStatus()
    },
    timestamp: new Date().toISOString()
  });
});

// Mount routes
app.use('/api/moondream', moondreamRoutes); // Existing
app.use('/api/cameras', rtspRoutes); // New RTSP routes

// Start RTSP service
async function startServices() {
  try {
    // Start Python RTSP backend as subprocess
    await rtspManager.start();
    console.log('✓ RTSP service started');
    
    // Start Express server
    app.listen(PORT, () => {
      console.log(`✓ Express server running on port ${PORT}`);
      console.log(`✓ All services ready`);
    });
  } catch (error) {
    console.error('Failed to start services:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully...');
  await rtspManager.stop();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, shutting down gracefully...');
  await rtspManager.stop();
  process.exit(0);
});

// Start everything
startServices();
```

### **5. Create backend/python/rtsp_server.py**

```python
"""
Standalone RTSP streaming service
Runs as subprocess managed by Express
"""
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.responses import Response
from pydantic import BaseModel
import asyncio
import json
import base64
import os
import sys
from services.camera_manager import CameraManager

app = FastAPI(title="RTSP Service")

# Camera manager
camera_manager = CameraManager()

class CameraConnect(BaseModel):
    cameraId: str
    ip: str
    username: str
    password: str
    streamPath: str = "/1"

class CameraDisconnect(BaseModel):
    cameraId: str

@app.get("/health")
async def health_check():
    return {
        "status": "ok",
        "activeCameras": camera_manager.get_active_count()
    }

@app.post("/api/cameras/connect")
async def connect_camera(data: CameraConnect):
    try:
        rtsp_url = f"rtsp://{data.username}:{data.password}@{data.ip}:554{data.streamPath}"
        await camera_manager.connect_camera(data.cameraId, rtsp_url)
        
        return {
            "success": True,
            "cameraId": data.cameraId,
            "message": "Camera connected successfully"
        }
    except Exception as e:
        print(f"Connection error: {e}", file=sys.stderr, flush=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/cameras/disconnect")
async def disconnect_camera(data: CameraDisconnect):
    try:
        await camera_manager.disconnect_camera(data.cameraId)
        return {"success": True, "message": "Camera disconnected"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/cameras/{camera_id}/status")
async def get_camera_status(camera_id: str):
    status = camera_manager.get_camera_status(camera_id)
    if not status:
        raise HTTPException(status_code=404, detail="Camera not found")
    return status

@app.get("/api/cameras/{camera_id}/frame")
async def get_frame(camera_id: str):
    try:
        frame = await camera_manager.capture_frame(camera_id)
        if frame is None:
            raise HTTPException(status_code=404, detail="No frame available")
        
        return Response(content=frame, media_type="image/jpeg")
    except Exception as e:
        print(f"Frame error: {e}", file=sys.stderr, flush=True)
        raise HTTPException(status_code=500, detail=str(e))

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    camera_id = None
    stream_task = None
    
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            
            action = message.get("action")
            
            if action == "subscribe":
                camera_id = message.get("cameraId")
                fps = message.get("fps", 15)
                
                if stream_task:
                    stream_task.cancel()
                
                async def stream_frames():
                    interval = 1.0 / fps
                    
                    while True:
                        try:
                            frame = await camera_manager.capture_frame(camera_id)
                            
                            if frame:
                                frame_b64 = base64.b64encode(frame).decode('utf-8')
                                
                                await websocket.send_json({
                                    "type": "frame",
                                    "cameraId": camera_id,
                                    "data": frame_b64,
                                    "timestamp": asyncio.get_event_loop().time()
                                })
                            
                            await asyncio.sleep(interval)
                            
                        except asyncio.CancelledError:
                            break
                        except Exception as e:
                            print(f"Stream error: {e}", file=sys.stderr, flush=True)
                            await asyncio.sleep(1)
                
                stream_task = asyncio.create_task(stream_frames())
                
            elif action == "unsubscribe":
                if stream_task:
                    stream_task.cancel()
                    stream_task = None
                camera_id = None
                
            elif action == "ping":
                await websocket.send_json({"type": "pong"})
                
    except WebSocketDisconnect:
        pass
    except Exception as e:
        print(f"WebSocket error: {e}", file=sys.stderr, flush=True)
    finally:
        if stream_task:
            stream_task.cancel()

@app.on_event("shutdown")
async def shutdown_event():
    await camera_manager.disconnect_all()

if __name__ == "__main__":
    import uvicorn
    
    port = int(os.getenv("PORT", 8082))
    
    # Force flush for subprocess stdout
    print(f"Starting RTSP service on port {port}", flush=True)
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=port,
        log_level="info"
    )
```

### **6. Keep Python services files** (rtsp_service.py, camera_manager.py from before)

Copy the exact same `services/rtsp_service.py` and `services/camera_manager.py` from my previous message into `backend/python/services/`.

---

## Setup Instructions

### **1. Install Python Dependencies**

```bash
cd backend
npm run setup-python
```

### **2. Start Unified Backend**

```bash
npm start
```

This will:
1. Start Express on port 5000
2. Automatically spawn Python RTSP service on port 8082
3. Proxy all RTSP requests through Express

### **3. Test**

```bash
# Health check (should show both services)
curl http://localhost:5000/health

# Connect camera (through Express proxy)
curl -X POST http://localhost:5000/api/cameras/connect \
  -H "Content-Type: application/json" \
  -d '{
    "cameraId": "cam1",
    "ip": "192.168.1.100",
    "username": "admin",
    "password": "admin"
  }'

# Get frame
curl http://localhost:5000/api/cameras/cam1/frame --output frame.jpg
```

---

## Benefits of This Approach

✅ **Single command to start**: `npm start` launches everything  
✅ **Unified API**: All endpoints under `localhost:5000`  
✅ **Automatic cleanup**: Python process stops when Express stops  
✅ **Error handling**: Express monitors Python health  
✅ **Easier deployment**: One service to deploy  
✅ **Better logging**: All logs in one place  

---

## For Replit Deployment

Update `.replit`:

```toml
run = "cd backend && npm run setup-python && npm start"
```

That's it! One backend, all features, automatic startup.

**Want me to provide the complete merged file structure ready to copy-paste into Replit?**